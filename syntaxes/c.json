{
    "$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
    "information_for_contributors": [
				"Derived from C.tmLanguage - the original TextMate and Sublime Text syntax definition.",
				"Additional syntax definitions were added by <ergotamin@e-p-s.org>"
    ],
    "version": "1.2.0",
    "scopeName": "source.c",
    "fileTypes": [
        "c",
        "h"
    ],
    "firstLineMatch": "(?i)-\\\\*-[^*]*(Mode:\\\\s*)?C(\\\\s*;.*?)?\\\\s*-\\\\*-",
    "foldingStartMarker": "(?x)\n\t\t /\\*\\*(?!\\*)\n\t\t|^(?![^{]*?//|[^{]*?/\\*(?!.*?\\*/.*?\\{)).*?\\{\\s*($|//|/\\*(?!.*?\\*/.*\\S))\n\t",
    "foldingStopMarker": "(?<!\\*)\\*\\*/|^\\s*\\}",
    "name": "C",
    "patterns": [
        {
            "include": "#translation_unit"
        }
    ],
    "repository": {
        "translation_unit": {
            "patterns": [
                {
                    "include": "#special_block"
                },
                {
                    "include": "#typedef"
                },
                {
                    "include": "#type"
                },
                {
                    "include": "#lex"
                },
                {
                    "include": "#support-macro"
                },
                {
                    "include": "#function"
                },
                {
                    "include": "#support"
                },
                {
                    "include": "#block"
                },
                {
                    "include": "#parens"
                }
            ]
        },
        "special_block": {
            "begin": "(?x)\n\t\t\t\t(?= \\s*\n\t\t\t\t    (?:\n\t\t\t\t        (?: \\b extern \\b\n\t\t\t\t            (?: \"(\\\\.|[^\"])*\" | '(\\\\.|[^'])*' | /\\*.*?\\*/ | \\s)* ) |\n\t\t\t\t        (?: \\b namespace \\b\n\t\t\t\t            (?: (?: /\\*.*?\\*/ | \\s)* \\b [A-Za-z_]\\w*+ \\b)?\n\t\t\t\t            (?: /\\*.*?\\*/ | \\s)* ) )\n\t\t\t\t    \\{ )\n\t\t\t",
            "end": "\\}",
            "patterns": [
                {
                    "include": "#lex"
                },
                {
                    "begin": "\\{",
                    "end": "(?=\\})",
                    "name": "meta.block.special.c",
                    "patterns": [
                        {
                            "include": "$base"
                        }
                    ]
                }
            ]
        },
        "block": {
            "begin": "(?=\\{)",
            "end": "\\}",
            "patterns": [
                {
                    "include": "#block-lookahead-end"
                }
            ]
        },
        "block-lookahead-end": {
            "begin": "\\{",
            "end": "(?=\\})",
            "name": "meta.block.c",
            "patterns": [
                {
                    "include": "#typedef"
                },
                {
                    "include": "#type"
                },
                {
                    "include": "#lex"
                },
                {
                    "include": "#call"
                },
                {
                    "include": "#support"
                },
                {
                    "include": "#function"
                },
                {
                    "include": "$base"
                }
            ]
        },
        "parens": {
            "begin": "(?=\\()",
            "end": "\\)",
            "patterns": [
                {
                    "include": "#parens-lookahead-end"
                }
            ]
        },
        "parens-lookahead-end": {
            "begin": "\\(",
            "end": "(?=\\))",
            "name": "meta.parens.c",
            "patterns": [
                {
                    "include": "#type"
                },
                {
                    "include": "#lex"
                },
                {
                    "include": "#call"
                },
                {
                    "include": "#support"
                },
                {
                    "include": "$base"
                }
            ]
        },
        "typedef": {
            "begin": "(?x) (?<= \\A typedef | \\W typedef ) \\b",
            "end": ";",
            "name": "meta.typedef.c",
            "patterns": [
                {
                    "include": "#lex"
                },
                {
                    "include": "#type-definition"
                },
                {
                    "include": "#block"
                },
                {
                    "match": "\\s*\\b([A-Za-z_]\\w*+)(?=\\s*[\\[;])",
                    "captures": {
                        "1": {
                            "name": "entity.name.type.typedef.c"
                        }
                    }
                }
            ]
        },
        "type": {
            "patterns": [
                {
                    "include": "#type-declaration"
                },
                {
                    "include": "#type-definition"
                }
            ]
        },
        "type-declaration": {
            "begin": "(?x)\n\t\t\t\t(?<= \\A enum | \\A (?:class|union) | \\A struct |\n\t\t\t\t        \\W enum | \\W (?:class|union) | \\W struct ) \\b\n\t\t\t\t(?= (?:\\s|/\\*.*?\\*/)*+\n\t\t\t\t    ([A-Za-z_]\\w*+)\n\t\t\t\t    (?:\\s|/\\*.*?\\*/)*+; )\n\t\t\t",
            "end": "(?<=;)",
            "name": "meta.compound.c",
            "patterns": [
                {
                    "include": "#lex"
                },
                {
                    "match": "\\s*\\b([A-Za-z_]\\w*+)\\b",
                    "captures": {
                        "1": {
                            "name": "entity.name.type.declaration.c"
                        }
                    }
                }
            ]
        },
        "type-definition": {
            "begin": "(?x)\n\t\t\t\t(?<= \\A enum | \\A (?:class|union) | \\A struct |\n\t\t\t\t        \\W enum | \\W (?:class|union) | \\W struct ) \\b\n\n\t\t\t\t# Negation of zero-length parts of the end pattern\n\t\t\t\t# to prevent entering the rule if it's gonna exit immediately.\n\t\t\t\t# (workaround ST2 bugs, see issue #10)\n\t\t\t\t(?=\\s*(?:[A-Za-z_({]|/[/*]|$))\n\t\t\t\t(?! \\s*\\b(?: [A-Za-z_]\\w*+ ) (?= \\s* [\\[;] ) )\n\t\t\t",
            "end": "(?x)\n\t\t\t\t(?: (?!\\s*(?:[A-Za-z_({]|/[/*]|$))\n\t\t\t\t  | (?= \\s*\\b(?: [A-Za-z_]\\w*+ ) (?= \\s* [\\[;] ) )\n\t\t\t\t  | (?<!\\})(?=\n\t\t\t\t        # Prefer function definition over an attribute defined\n\t\t\t\t        # through a macro, unless a block has been seen. That is:\n\t\t\t\t        #   struct __packed __aligned(16) foo {...}; - function __aligned\n\t\t\t\t        #   struct foo {...} __packed __aligned(16); - structure foo\n\t\t\t\t        (?! \\s* \\b__attribute__\\b )\n\n\t\t\t\t        (?: ^\n\t\t\t\t          | (?<! (?<!\\w) new\n\t\t\t\t                | (?<!\\w) (?:else|enum) | (?<!\\w) (?:class|union)\n\t\t\t\t                | (?<!\\w) (?:struct|return|sizeof|typeof)\n\t\t\t\t                | (?<!\\w) __typeof | (?<!\\w) __typeof__ )\n\t\t\t\t            (?<= \\w ) \\s\n\n\t\t\t\t          | #  or type modifier / closing bracket before name\n\t\t\t\t            (?<= [^&]& | [*>)}\\]] ) ) \\s*\n\n\t\t\t\t        (?: [A-Za-z_]\\w*+ | ::[^:] )++\n\t\t\t\t        (?: (?<= ^ operator | \\W operator )  # C++ operator?\n\t\t\t\t            (?: [-*&<>=+!]+ | \\(\\) | \\[\\] ) )?\n\t\t\t\t        (?:\\s|/\\*.*?\\*/)*+ \\( ) )\n\t\t\t",
            "name": "meta.compound.c",
            "patterns": [
                {
                    "begin": "(?<=\\})",
                    "end": "(?!\\s*(?:[A-Za-z_({]|/[/*]|$))",
                    "patterns": [
                        {
                            "include": "#lex"
                        },
                        {
                            "include": "#block"
                        },
                        {
                            "include": "#parens"
                        }
                    ]
                },
                {
                    "include": "#lex"
                },
                {
                    "include": "#block"
                },
                {
                    "include": "#parens"
                },
                {
                    "match": "\\b([A-Za-z_]\\w*+)(?=(?:\\s|/\\*.*?\\*/)*+(?:\\{|(//.*)?\\\\?$))",
                    "captures": {
                        "1": {
                            "name": "entity.name.type.class.c entity.name.class.c"
                        }
                    }
                }
            ]
        },
        "function": {
            "patterns": [
                {
                    "include": "#function-fixup-macro"
                },
                {
                    "include": "#function-declaration"
                },
                {
                    "include": "#function-definition"
                }
            ]
        },
        "function-fixup-macro": {
            "begin": "(?x)\n\t\t\t\t^ # Begin of line, capital letters: most probably it is a macro\n\t\t\t\t\\s*\\b\n\t\t\t\t([A-Z0-9_]++)\n\t\t\t\t\\b\n\t\t\t\t(?= (?:\\s|/\\*.*?\\*/)*+ \\( )\n\t\t\t",
            "end": "\\)",
            "patterns": [
                {
                    "include": "#lex"
                },
                {
                    "include": "#parens-lookahead-end"
                }
            ]
        },
        "function-declaration": {
            "name": "meta.function.c",
            "begin": "(?x)\n\t\t\t\t(?: ^\n\t\t\t\t  | (?<! (?<!\\w) new\n\t\t\t\t        | (?<!\\w) (?:else|enum) | (?<!\\w) (?:class|union)\n\t\t\t\t        | (?<!\\w) (?:struct|return|sizeof|typeof)\n\t\t\t\t        | (?<!\\w) __typeof | (?<!\\w) __typeof__ )\n\t\t\t\t    (?<= \\w ) \\s\n\n\t\t\t\t  | #  or type modifier / closing bracket before name\n\t\t\t\t    (?<= [^&]& | [*>)}\\]] ) ) \\s*\n\n\t\t\t\t(   (?: [A-Za-z_]\\w*+ | ::[^:] )++\n\t\t\t\t    (?: (?<= ^ operator | \\W operator )  # C++ operator?\n\t\t\t\t        (?: [-*&<>=+!]+ | \\(\\) | \\[\\] ) )? )\n\n\t\t\t\t(?= (?:\\s|/\\*.*?\\*/)*+ (?'parens' \\(\n\t\t\t\t            (?> \\g'parens' |\n\t\t\t\t            \t\"(\\\\.|[^\"])*\" | '(\\\\.|[^'])*' | /\\*.*?\\*/ |\n\t\t\t\t            \t(?! /[/*] | [()] ) . )*\n\t\t\t\t        \\) ) \\s* ; )\n\t\t\t",
            "beginCaptures": {
                "1": {
                    "name": "entity.name.function.declaration.c"
                }
            },
            "end": ";",
            "patterns": [
                {
                    "include": "#lex"
                },
                {
                    "include": "#parens"
                }
            ]
        },
        "function-definition": {
            "name": "meta.function.c",
            "begin": "(?x)\n\t\t\t\t(?: ^\n\t\t\t\t  | (?<! (?<!\\w) new\n\t\t\t\t        | (?<!\\w) (?:else|enum) | (?<!\\w) (?:class|union)\n\t\t\t\t        | (?<!\\w) (?:struct|return|sizeof|typeof)\n\t\t\t\t        | (?<!\\w) __typeof | (?<!\\w) __typeof__ )\n\t\t\t\t    (?<= \\w ) \\s\n\n\t\t\t\t  | #  or type modifier / closing bracket before name\n\t\t\t\t    (?<= [^&]& | [*>)}\\]] ) ) \\s*\n\n\t\t\t\t(   (?: [A-Za-z_]\\w*+ | ::[^:] )++\n\t\t\t\t    (?: (?<= ^ operator | \\W operator )  # C++ operator?\n\t\t\t\t        (?: [-*&<>=+!]+ | \\(\\) | \\[\\] ) )? )\n\n\t\t\t\t(?= (?:\\s|/\\*.*?\\*/)*+ \\( )\n\t\t\t",
            "beginCaptures": {
                "1": {
                    "name": "entity.name.function.definition.c"
                }
            },
            "end": "\\}|;",
            "patterns": [
                {
                    "include": "#lex"
                },
                {
                    "include": "#parens"
                },
                {
                    "match": "\\s*\\b(const|override)\\b",
                    "name": "storage.modifier.c"
                },
                {
                    "include": "#block-lookahead-end"
                }
            ]
        },
        "call": {
            "name": "meta.function-call.c",
            "begin": "(?x)\n\t\t\t\t\\s*\n\t\t\t\t(?= # don't consume to recognize support functions\n\t\t\t\t    (?: [A-Za-z_]\\w*+ | ::[^:] )++\n\t\t\t\t    (?:\\s|/\\*.*?\\*/)*+ \\( )\n\t\t\t",
            "end": "\\)",
            "patterns": [
                {
                    "include": "#lex"
                },
                {
                    "include": "#support-function"
                },
                {
                    "match": "(?:(?<=\\.)|(?<=->))\\b([A-Za-z_]\\w*+)\\b",
                    "name": "variable.other.dot-access.c support.function.any-method.c"
                },
                {
                    "match": "(?:[A-Za-z_]\\w*+|::[^:])++",
                    "name": "support.function.any-method.c"
                },
                {
                    "include": "#parens-lookahead-end"
                }
            ]
        },
        "preprocessor": {
            "begin": "(?=^\\s*(#))",
            "end": "(?!^\\s*(#))",
            "patterns": [
                {
                    "include": "#preprocessor-disabled"
                },
                {
                    "include": "#ppline-directive-invalid-usage"
                },
                {
                    "include": "#ppline-macro"
                },
                {
                    "include": "#ppline-undef"
                },
                {
                    "include": "#ppline-pragma-mark"
                },
                {
                    "include": "#ppline-include"
                },
                {
                    "include": "#ppline-directive"
                },
                {
                    "include": "#ppline-directive-obsolete"
                },
                {
                    "include": "#ppline-invalid"
                },
                {
                    "include": "#ppline-any"
                }
            ]
        },
        "preprocessor-lex": {
            "patterns": [
                {
                    "include": "#comments"
                },
                {
                    "include": "#lex-continuation"
                },
                {
                    "include": "#lex-newline"
                }
            ]
        },
        "preprocessor-disabled": {
            "begin": "^\\s*(#)(?=\\s*(if)\\b(?=(?:\\s|/\\*.*?\\*/)*+(0[xX])?0++\\b(?:\\s|/\\*.*?\\*/)*+(//.*)?\\\\?$))",
            "beginCaptures": {
                "0": {
                    "name": "meta.preprocessor.directive.c keyword.other.preprocessor.c"
                }
            },
            "end": "(?=^\\s*(#)\\s*(endif|else|elif)\\b)",
            "patterns": [
                {
                    "begin": "^",
                    "end": "$\\n?",
                    "name": "comment.other.preprocessor-disabled.c",
                    "patterns": [
                        {
                            "include": "#preprocessor-disabled-conditional"
                        },
                        {
                            "include": "#preprocessor-disabled-directive"
                        }
                    ]
                },
                {
                    "begin": "(?<!##)(?<=#)\\s*(if)\\b(?=(?:\\s|/\\*.*?\\*/)*+(0[xX])?0++\\b(?:\\s|/\\*.*?\\*/)*+(//.*)?\\\\?$)",
                    "beginCaptures": {
                        "1": {
                            "name": "keyword.other.preprocessor.define.c"
                        }
                    },
                    "end": "(?<=$\\n)(?<!\\\\$\\n)",
                    "name": "meta.preprocessor.directive.c",
                    "patterns": [
                        {
                            "include": "#lex-core"
                        }
                    ]
                }
            ]
        },
        "preprocessor-disabled-conditional": {
            "begin": "^\\s*(#)\\s*if(n?def)?\\b",
            "end": "^\\s*(#)\\s*endif\\b.*$\\n?",
            "patterns": [
                {
                    "include": "#preprocessor-disabled-conditional"
                },
                {
                    "include": "#preprocessor-disabled-directive"
                }
            ]
        },
        "preprocessor-disabled-directive": {
            "begin": "^\\s*(#)",
            "end": "(?<=$\\n)(?<!\\\\$\\n)"
        },
        "ppline-macro": {
            "begin": "^\\s*(#)(?=\\s*(define)\\s+[a-zA-Z_]\\w*+)",
            "beginCaptures": {
                "0": {
                    "name": "keyword.other.preprocessor.c"
                }
            },
            "end": "(?<=$\\n)(?<!\\\\$\\n)",
            "name": "meta.preprocessor.macro.c",
            "patterns": [
                {
                    "match": "\\s*(##)",
                    "captures": {
                        "1": {
                            "name": "keyword.other.preprocessor.c"
                        }
                    }
                },
                {
                    "match": "\\s*(#)\\s*([a-zA-Z_]\\w*+)",
                    "captures": {
                        "1": {
                            "name": "keyword.other.preprocessor.c"
                        },
                        "2": {
                            "name": "string.macro.stringify.c"
                        }
                    }
                },
                {
                    "include": "#ppline-macro-head-function"
                },
                {
                    "include": "#ppline-macro-head-object"
                },
                {
                    "include": "#lex-in-preprocessor"
                },
                {
                    "include": "#support"
                }
            ]
        },
        "ppline-macro-head-object": {
            "match": "(?<!##)(?<=#)(\\s*define)\\s+([a-zA-Z_]\\w*+)(?!\\()[\\s&&[^\\n]]*",
            "captures": {
                "1": {
                    "name": "keyword.other.preprocessor.define.c"
                },
                "2": {
                    "name": "entity.name.constant.preprocessor.c"
                }
            }
        },
        "ppline-macro-head-function": {
            "begin": "(?<!##)(?<=#)(\\s*define)\\s+([a-zA-Z_]\\w*+)(\\()",
            "beginCaptures": {
                "1": {
                    "name": "keyword.other.preprocessor.define.c"
                },
                "2": {
                    "name": "entity.name.function.preprocessor.c"
                },
                "3": {
                    "name": "meta.preprocessor.macro.parameters.c"
                }
            },
            "end": "(?<=\\))|(?<=^|[^\\\\])\\s*(\\n)",
            "endCaptures": {
                "1": {
                    "name": "invalid.illegal.unexpected-end-of-line.c"
                }
            },
            "contentName": "meta.preprocessor.macro.parameters.c",
            "patterns": [
                {
                    "match": "\\)"
                },
                {
                    "begin": "\\b([a-zA-Z_]\\w*+)\\b",
                    "beginCaptures": {
                        "1": {
                            "name": "variable.parameter.c"
                        }
                    },
                    "end": "(?<=\\))|(?=(?<=^|[^\\\\])\\s*(\\n))",
                    "patterns": [
                        {
                            "match": "\\)"
                        },
                        {
                            "include": "#ppline-macro-param-next"
                        },
                        {
                            "include": "#ppline-macro-param-vararg"
                        },
                        {
                            "include": "#ppline-macro-param-lex"
                        },
                        {
                            "include": "#ppline-macro-param-lex-invalid"
                        }
                    ]
                },
                {
                    "include": "#ppline-macro-param-vararg"
                },
                {
                    "include": "#ppline-macro-param-lex"
                },
                {
                    "include": "#ppline-macro-param-lex-invalid"
                }
            ]
        },
        "ppline-macro-param-next": {
            "begin": "(,)",
            "beginCaptures": {
                "1": {
                    "name": "punctuation.separator.parameter.c"
                }
            },
            "end": "\\b([a-zA-Z_]\\w*+)\\b|(?=\\.\\.\\.)|(\\))|(?=(?<=^|[^\\\\])\\s*(\\n))",
            "endCaptures": {
                "1": {
                    "name": "variable.parameter.c"
                },
                "2": {
                    "name": "invalid.illegal.unexpected-closing-paren.c"
                }
            },
            "patterns": [
                {
                    "include": "#ppline-macro-param-lex"
                },
                {
                    "match": "(?x)\n\t\t\t\t\t\t(?: (?! (?:\\s|/\\*.*?\\*/)*+\n\t\t\t\t\t\t\t    (?: \\b([a-zA-Z_]\\w*+)\\b | \\.\\.\\. | \\) | (?>(?:\\\\\\s*)?$\\n?) | /[/*] ) )\n\t\t\t\t\t\t    .)*\n\t\t\t\t\t",
                    "name": "invalid.illegal.unexpected-character.c"
                }
            ]
        },
        "ppline-macro-param-vararg": {
            "begin": "(\\.\\.\\.)",
            "beginCaptures": {
                "1": {
                    "name": "punctuation.definition.ellipsis.c"
                }
            },
            "end": "(\\))|(?=(?<=^|[^\\\\])\\s*(\\n))",
            "patterns": [
                {
                    "include": "#ppline-macro-param-lex"
                },
                {
                    "match": "(?x)\n\t\t\t\t\t\t(?: (?! (?:\\s|/\\*.*?\\*/)*+\n\t\t\t\t\t\t\t    (?: \\) | (?>(?:\\\\\\s*)?$\\n?) | /[/*] ) )\n\t\t\t\t\t\t    .)*\n\t\t\t\t\t",
                    "name": "invalid.illegal.unexpected-character.c"
                }
            ]
        },
        "ppline-macro-param-lex": {
            "patterns": [
                {
                    "match": "\\s*"
                },
                {
                    "begin": "\\s*//",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.definition.comment.c"
                        }
                    },
                    "end": "(?<=^|[^\\\\])\\s*(?=\\n)$",
                    "name": "invalid.illegal.unexpected-end-of-line.c",
                    "patterns": [
                        {
                            "include": "#lex-continuation"
                        }
                    ]
                },
                {
                    "include": "#preprocessor-lex"
                }
            ]
        },
        "ppline-macro-param-lex-invalid": {
            "patterns": [
                {
                    "match": "(?x)\n\t\t\t\t\t\t(?: (?! (?:\\s|/\\*.*?\\*/)*+\n\t\t\t\t\t\t        (?: \\) | (?>(?:\\\\\\s*)?$\\n?) | /[/*] ) )\n\t\t\t\t\t\t    .) # no star unlike its friends in arg/vararg\n\t\t\t\t\t",
                    "name": "invalid.illegal.unexpected-character.c"
                }
            ]
        },
        "ppline-undef": {
            "begin": "(^\\s*(#)\\s*(undef))\\s+([a-zA-Z_]\\w*+)",
            "beginCaptures": {
                "1": {
                    "name": "keyword.other.preprocessor.c"
                },
                "4": {
                    "name": "variable.macro.undef.c"
                }
            },
            "end": "(?<=$\\n)(?<!\\\\$\\n)",
            "name": "meta.preprocessor.undef.c",
            "patterns": []
        },
        "ppline-include": {
            "begin": "^\\s*(#)\\s*(include|include_next|import)\\b",
            "beginCaptures": {
                "0": {
                    "name": "keyword.other.preprocessor.include.c"
                }
            },
            "end": "(?:(\"[^\"]*?)|(<[^>]*?))(\\n)|(?<=$\\n)(?<!\\\\$\\n)",
            "endCaptures": {
                "1": {
                    "name": "string.quoted.double.include.c"
                },
                "2": {
                    "name": "string.quoted.other.lt-gt.include.c"
                },
                "3": {
                    "name": "invalid.illegal.unexpected-end-of-line.c"
                }
            },
            "name": "meta.preprocessor.include.c meta.preprocessor.c.include",
            "patterns": [
                {
                    "include": "#ppline-include-innards"
                }
            ]
        },
        "ppline-include-innards": {
            "patterns": [
                {
                    "include": "#preprocessor-lex"
                },
                {
                    "begin": "\"|(?=.*?\")",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.definition.string.begin.c"
                        }
                    },
                    "end": "\"|(?<=^|[^\\\\])(?=\\s*\\n)",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.definition.string.end.c"
                        }
                    },
                    "name": "string.quoted.double.include.c"
                },
                {
                    "begin": "<(?=.*?>)",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.definition.string.begin.c"
                        }
                    },
                    "end": ">|(?<=^|[^\\\\])(?=\\s*\\n)",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.definition.string.end.c"
                        }
                    },
                    "name": "string.quoted.other.lt-gt.include.c"
                },
                {
                    "begin": "\\(",
                    "end": "\\)|(?<=^|[^\\\\])(?=\\s*\\n)",
                    "name": "meta.parens.c",
                    "patterns": [
                        {
                            "include": "#ppline-include-innards"
                        }
                    ]
                }
            ]
        },
        "ppline-pragma-mark": {
            "begin": "(^\\s*(#)\\s*(pragma\\s+mark)\\b)[\\s&&[^\\n]]*",
            "beginCaptures": {
                "1": {
                    "name": "keyword.other.preprocessor.pragma.c"
                }
            },
            "end": "(?<=$\\n)(?<!\\\\$\\n)",
            "name": "meta.preprocessor.directive.pragma-mark.c",
            "contentName": "meta.toc-list.pragma-mark.c",
            "patterns": [
                {
                    "include": "#preprocessor-lex"
                },
                {
                    "match": ".",
                    "name": "string.other.pragma-mark.c"
                }
            ]
        },
        "ppline-directive": {
            "begin": "^\\s*(#)\\s*(if|ifdef|ifndef|elif|else|endif|pragma|line|define|undef|error|warning)\\b",
            "beginCaptures": {
                "0": {
                    "name": "keyword.other.preprocessor.c"
                }
            },
            "end": "(?<=$\\n)(?<!\\\\$\\n)",
            "name": "meta.preprocessor.directive.c",
            "patterns": [
                {
                    "include": "#lex-core"
                }
            ]
        },
        "ppline-directive-invalid-usage": {
            "match": "(^\\s*(#)\\s*(if|ifdef|ifndef|elif|pragma|define|undef|include|include_next|import)\\b)\\s*?(\\n|$)",
            "captures": {
                "1": {
                    "name": "keyword.other.preprocessor.c"
                },
                "4": {
                    "name": "invalid.illegal.invalid-usage-of-preprocessor-directive.c"
                }
            },
            "name": "meta.preprocessor.directive.c"
        },
        "ppline-directive-obsolete": {
            "begin": "^\\s*(#)\\s*(assert|unassert|ident|sccs)\\b",
            "end": "(?<=$\\n)(?<!\\\\$\\n)",
            "beginCaptures": {
                "1": {
                    "name": "keyword.other.preprocessor.c"
                },
                "2": {
                    "name": "invalid.deprecated.preprocessor.c"
                }
            },
            "name": "meta.preprocessor.directive.deprecated.c",
            "patterns": [
                {
                    "include": "#lex-core"
                }
            ]
        },
        "ppline-invalid": {
            "begin": "^\\s*(#)(?!\\s*(?=/[/*]|(?>\\\\\\s*\\n)|\\n|$))\\s*(\\w*)",
            "end": "(?<=$\\n)(?<!\\\\$\\n)",
            "beginCaptures": {
                "1": {
                    "name": "keyword.other.preprocessor.c"
                },
                "2": {
                    "name": "invalid.illegal.preprocessor.c"
                }
            },
            "name": "meta.preprocessor.directive.illegal.c"
        },
        "ppline-any": {
            "begin": "^\\s*(#)",
            "beginCaptures": {
                "0": {
                    "name": "keyword.other.preprocessor.c"
                }
            },
            "end": "(?<=$\\n)(?<!\\\\$\\n)",
            "name": "meta.preprocessor.directive.null-directive.c",
            "patterns": [
                {
                    "include": "#lex-core"
                }
            ]
        },
        "support": {
            "patterns": [
                {
                    "include": "#support-type"
                },
                {
                    "include": "#support-macro"
                },
                {
                    "include": "#support-function"
                }
            ]
        },
        "support-type": {
            "patterns": [
		{
		     "match": "\\b([A-Za-z0-9_]+_t)\\b",
                    "captures": {
                        "1": {
			"name": "support.type.posix-reserved.c"
				}
			}
		},
		{
			"match": "\\b(u_char|u_short|u_int|u_long|ushort|uint|u_quad_t|quad_t|qaddr_t|caddr_t|daddr_t|div_t|dev_t|fixpt_t|blkcnt_t|blksize_t|gid_t|in_addr_t|in_port_t|ino_t|key_t|mode_t|nlink_t|id_t|pid_t|off_t|segsz_t|swblk_t|uid_t|id_t|clock_t|size_t|ssize_t|time_t|useconds_t|suseconds_t)\\b",
                    "captures": {
                        "1": {
			"name": "support.type.sys-types.c"
				}
			}
		},
		{
			"match": "\\b(pthread_attr_t|pthread_cond_t|pthread_condattr_t|pthread_mutex_t|pthread_mutexattr_t|pthread_once_t|pthread_rwlock_t|pthread_rwlockattr_t|pthread_t|pthread_key_t)\\b",
                    "captures": {
                        "1": {
			"name": "support.type.pthread.c"
				}
			}
		},
                {
                    "match": "\\s*\\b(u?int(?:(?:_least|_fast)?(?:8|16|32|64)_t|ptr_t|max_t))\\b",
                    "captures": {
                        "1": {
                            "name": "support.type.stdint.c"
                        }
                    }
                },
                {
                    "match": "\\s*\\b(noErr|kNilOptions|kInvalidID|kVariableLengthArray)\\b",
                    "captures": {
                        "1": {
                            "name": "support.constant.mac-classic.c"
                        }
                    }
                },
                {
                    "match": "\\s*\\b(AbsoluteTime|Boolean|Byte|ByteCount|ByteOffset|BytePtr|CompTimeValue|ConstLogicalAddress|ConstStrFileNameParam|ConstStringPtr|Duration|Fixed|FixedPtr|Float32|Float32Point|Float64|Float80|Float96|FourCharCode|Fract|FractPtr|Handle|ItemCount|LogicalAddress|OptionBits|OSErr|OSStatus|OSType|OSTypePtr|PhysicalAddress|ProcessSerialNumber|ProcessSerialNumberPtr|ProcHandle|Ptr|ResType|ResTypePtr|ShortFixed|ShortFixedPtr|SignedByte|SInt16|SInt32|SInt64|SInt8|Size|StrFileName|StringHandle|StringPtr|TimeBase|TimeRecord|TimeScale|TimeValue|TimeValue64|UInt16|UInt32|UInt64|UInt8|UniChar|UniCharCount|UniCharCountPtr|UniCharPtr|UnicodeScalarValue|UniversalProcHandle|UniversalProcPtr|UnsignedFixed|UnsignedFixedPtr|UnsignedWide|UTF16Char|UTF32Char|UTF8Char)\\b",
                    "captures": {
                        "1": {
                            "name": "support.type.mac-classic.c"
                        }
                    }
                },
                {
                    "match": "(?x)\n\t\t\t\t\t\t\\s*\\b\n\t\t\t\t\t\t(   Py(?:Var|Type|HeapType|Dict|Set|List|Tuple|BaseException)?Object\n\t\t\t\t\t\t  | PyType_(?:Spec|Slot) )\n\t\t\t\t\t\t\\b\n\t\t\t\t\t",
                    "captures": {
                        "1": {
                            "name": "support.type.cpython.c"
                        }
                    }
                },
                {
                    "match": "(?x)\n\t\t\t\t\t\t\\s*\\b\n\t\t\t\t\t\t(   Py(?:BaseObject|Type|Super|Bool|Dict\n\t\t\t\t\t\t        |DictIter(?:Key|Value|Item)\n\t\t\t\t\t\t        |Dict(?:Key|Value|Item)s\n\t\t\t\t\t\t        |(?:Set|List|Tuple)(?:Iter)?\n\t\t\t\t\t\t        |FrozenSet|ListRevIter)_Type\n\t\t\t\t\t\t  | _?PyExc_\\w++\n\t\t\t\t\t\t  | Py_(?:False|True|None|NotImplemented) )\n\t\t\t\t\t\t\\b\n\t\t\t\t\t",
                    "captures": {
                        "1": {
                            "name": "support.constant.cpython.c"
                        }
                    }
                }
            ]
        },
        "support-macro": {
            "patterns": [
                {
                    "match": "\\s*\\b(__builtin_\\w++)\\b",
                    "captures": {
                        "1": {
                            "name": "support.function.intrinsic.c"
                        }
                    }
                },
                {
                    "match": "(?x)\n\t\t\t\t\t\t\\s*\\b\n\t\t\t\t\t\t(   (?:__)?(?:DECL(?:ARE)?|DEF(?:INE)?)_[A-Z0-9_]+\n\t\t\t\t\t\t  | (?:__)?[A-Z_][A-Z0-9_]*_(?:DECL(?:ARE)?|DEF(?:INE)?)\n\t\t\t\t\t\t  | EXPORT(?:_UNUSED)?(?:_PER_CPU)?_SYMBOL(?:_GPL(?:_FUTURE)?)?\n\t\t\t\t\t\t  | MODULE_(?:INFO|ALIAS|LICENSE|AUTHOR|DESCRIPTION|DEVICE_TABLE|VERSION|FIRMWARE)\n\t\t\t\t\t\t  | (?:__)?MODULE_PARM_(?:TYPE|DESC)\n\t\t\t\t\t\t  | module_param(?:(?:_array)?(?:_named)?|_call)\n\t\t\t\t\t\t  | (?:module|core|postcore|arch|subsys|fs|device|late)_param_cb\n\t\t\t\t\t\t  | [HL]?LIST_HEAD\n\t\t\t\t\t\t  | (?:_|__BIN|BIN|BUS|DRIVER|CLASS|DEVICE)_ATTR(?:_R[OW])? )\n\t\t\t\t\t\t\\b\n\t\t\t\t\t",
                    "captures": {
                        "1": {
                            "name": "support.function.linux-kernel.macro.c"
                        }
                    }
                },
                {
                    "match": "(?x)\n\t\t\t\t\t\t\\s*\\b\n\t\t\t\t\t\t(   _(?:IRQL|Kernel)_\\w+_\n\t\t\t\t\t\t  | _Interlocked_operand_\n\t\t\t\t\t\t  | _Dispatch_type_\n\t\t\t\t\t\t  | _Flt_CompletionContext_Outptr_ )\n\t\t\t\t\t\t\\b\n\t\t\t\t\t",
                    "captures": {
                        "1": {
                            "name": "support.function.windows-sal2.annotation.c"
                        }
                    }
                },
                {
                    "match": "(?x)\n\t\t\t\t\t\t\\s*\\b\n\t\t\t\t\t\t(   PyAPI_(?:FUNC|DATA)\n\t\t\t\t\t\t  | PyMODINIT_FUNC\n\t\t\t\t\t\t  | Py_LOCAL(?:_INLINE)?\n\t\t\t\t\t\t  | PyDoc_(?:STR(?:VAR)?|VAR)\n\t\t\t\t\t\t  | PyObject(?:_VAR)?_HEAD\n\t\t\t\t\t\t  | _PyObject_HEAD_EXTRA\n\t\t\t\t\t\t  | PyException_HEAD\n\t\t\t\t\t\t  | Py(?:Var)?Object_HEAD_INIT\n\t\t\t\t\t\t  | PyModuleDef_HEAD_INIT\n\t\t\t\t\t\t  | Py_(RETURN)_(?:FALSE|TRUE|NONE|NOTIMPLEMENTED|NAN|INF) )\n\t\t\t\t\t\t\\b\n\t\t\t\t\t",
                    "captures": {
                        "1": {
                            "name": "support.function.cpython.macro.c"
                        },
                        "2": {
                            "name": "keyword.control.c"
                        }
                    }
                },
                {
                    "match": "\\s*\\b(_Py_IDENTIFIER)\\b\\s*\\(\\s*([A-Za-z_]\\w*+)\\s*\\)",
                    "captures": {
                        "1": {
                            "name": "support.function.cpython.macro.c"
                        },
                        "2": {
                            "name": "string.support.cpython.identifier.c"
                        }
                    }
                },
                {
                    "match": "\\s*\\bPyId_([A-Za-z_]\\w*+)\\b",
                    "captures": {
                        "1": {
                            "name": "string.support.cpython.identifier.c"
                        }
                    }
                },
                {
                    "match": "\\s*\\b((?:CONFIG|HAVE)_[A-Z0-9_]++)\\b",
                    "captures": {
                        "1": {
                            "name": "support.constant.config.c"
                        }
                    }
                }
            ]
        },
        "support-function": {
            "patterns": [
                {
                    "match": "\\s*\\b(hypot(f|l)?|s(scanf|ystem|nprintf|ca(nf|lb(n(f|l)?|ln(f|l)?))|i(n(h(f|l)?|f|l)?|gn(al|bit))|tr(s(tr|pn)|nc(py|at|mp)|c(spn|hr|oll|py|at|mp)|to(imax|d|u(l(l)?|max)|k|f|l(d|l)?)|error|pbrk|ftime|len|rchr|xfrm)|printf|et(jmp|vbuf|locale|buf)|qrt(f|l)?|w(scanf|printf)|rand)|n(e(arbyint(f|l)?|xt(toward(f|l)?|after(f|l)?))|an(f|l)?)|c(s(in(h(f|l)?|f|l)?|qrt(f|l)?)|cos(h(f)?|f|l)?|imag(f|l)?|t(ime|an(h(f|l)?|f|l)?)|o(s(h(f|l)?|f|l)?|nj(f|l)?|pysign(f|l)?)|p(ow(f|l)?|roj(f|l)?)|e(il(f|l)?|xp(f|l)?)|l(o(ck|g(f|l)?)|earerr)|a(sin(h(f|l)?|f|l)?|cos(h(f|l)?|f|l)?|tan(h(f|l)?|f|l)?|lloc|rg(f|l)?|bs(f|l)?)|real(f|l)?|brt(f|l)?)|t(ime|o(upper|lower)|an(h(f|l)?|f|l)?|runc(f|l)?|gamma(f|l)?|mp(nam|file))|i(s(space|n(ormal|an)|cntrl|inf|digit|u(nordered|pper)|p(unct|rint)|finite|w(space|c(ntrl|type)|digit|upper|p(unct|rint)|lower|al(num|pha)|graph|xdigit|blank)|l(ower|ess(equal|greater)?)|al(num|pha)|gr(eater(equal)?|aph)|xdigit|blank)|logb(f|l)?|max(div|abs))|di(v|fftime)|_Exit|unget(c|wc)|p(ow(f|l)?|ut(s|c(har)?|wc(har)?)|error|rintf)|e(rf(c(f|l)?|f|l)?|x(it|p(2(f|l)?|f|l|m1(f|l)?)?))|v(s(scanf|nprintf|canf|printf|w(scanf|printf))|printf|f(scanf|printf|w(scanf|printf))|w(scanf|printf)|a_(start|copy|end|arg))|qsort|f(s(canf|e(tpos|ek))|close|tell|open|dim(f|l)?|p(classify|ut(s|c|w(s|c))|rintf)|e(holdexcept|set(e(nv|xceptflag)|round)|clearexcept|testexcept|of|updateenv|r(aiseexcept|ror)|get(e(nv|xceptflag)|round))|flush|w(scanf|ide|printf|rite)|loor(f|l)?|abs(f|l)?|get(s|c|pos|w(s|c))|re(open|e|ad|xp(f|l)?)|m(in(f|l)?|od(f|l)?|a(f|l|x(f|l)?)?))|l(d(iv|exp(f|l)?)|o(ngjmp|cal(time|econv)|g(1(p(f|l)?|0(f|l)?)|2(f|l)?|f|l|b(f|l)?)?)|abs|l(div|abs|r(int(f|l)?|ound(f|l)?))|r(int(f|l)?|ound(f|l)?)|gamma(f|l)?)|w(scanf|c(s(s(tr|pn)|nc(py|at|mp)|c(spn|hr|oll|py|at|mp)|to(imax|d|u(l(l)?|max)|k|f|l(d|l)?|mbs)|pbrk|ftime|len|r(chr|tombs)|xfrm)|to(b|mb)|rtomb)|printf|mem(set|c(hr|py|mp)|move))|a(s(sert|ctime|in(h(f|l)?|f|l)?)|cos(h(f|l)?|f|l)?|t(o(i|f|l(l)?)|exit|an(h(f|l)?|2(f|l)?|f|l)?)|b(s|ort))|g(et(s|c(har)?|env|wc(har)?)|mtime)|r(int(f|l)?|ound(f|l)?|e(name|alloc|wind|m(ove|quo(f|l)?|ainder(f|l)?))|a(nd|ise))|b(search|towc)|m(odf(f|l)?|em(set|c(hr|py|mp)|move)|ktime|alloc|b(s(init|towcs|rtowcs)|towc|len|r(towc|len))))\\b",
                    "captures": {
                        "1": {
                            "name": "support.function.C99.c"
                        }
                    }
                },
                {
                    "match": "(?x)\n\t\t\t\t\t\t\\s*\\b\n\t\t\t\t\t\t(   Py_REFCNT | Py_TYPE | Py_SIZE\n\t\t\t\t\t\t  | Py_X?(?:INC|DEC)REF | Py_CLEAR\n\t\t\t\t\t\t  | _?Py(?:Object|Type|HeapType|Dict|Set|List|Tuple|Long|Exception|Err)_\\w++ )\n\t\t\t\t\t\t\\b\n\t\t\t\t\t",
                    "captures": {
                        "1": {
                            "name": "support.function.cpython.c"
                        }
                    }
                }
            ]
        },
        "comments": {
            "patterns": [
                {
                    "begin": "\\s*(/\\*)",
                    "captures": {
                        "1": {
                            "name": "punctuation.definition.comment.block.c"
                        }
                    },
                    "end": "(\\*/)(\\n?)",
                    "endCaptures": {
                        "2": {
                            "name": "punctuation.whitespace.newline.c"
                        }
                    },
                    "name": "comment.block.c",
                    "patterns": [
                        {
                            "begin": "[!](\\w*:?re2c:?\\w*)",
                            "captures": {
                                "1": {
                                    "name": "keyword.operator.c"
                                }
                            },
                            "contentName": "source.pcre",
                            "patterns": [
                                {
                                    "include": "source.pcre"
                                },
                                {
                                    "begin": "[^\\x{0022}](\\{)",
                                    "captures": {
                                        "1": {
                                            "name": "meta.brace.curly.begin.c"
                                        }
                                    },
                                    "patterns":
                                    [
                                        {
                                            "include": "source.cpp"
                                        }
                                    ],
                                    "end": "[^\\x{0022}](\\})",
                                    "endCaptures": {
                                        "1": {
                                            "name": "meta.brace.curly.end.c"
                                        }
                                    }
                                }
                            ],
                            "end": "\\s*(?=(\\*/))",
                            "endCaptures": {
                                "1": {
                                    "name": "punctuation.definition.comment.block.c"
                                }
                            }
                        },
                        {
                            "include": "#comment-innards"
												},
												{
																		"match": "\\s*([@][^A-Z\\s]++)\\s*",
																		"captures": {
																		"1": {
																				"name": "comment.block.jdoc.c"
																				}
										 								}
												},
												{
																		"match": "\\s*([A-Z][a-z]+:)(\\s*\\S*\\s*)",
																		"captures": {
																		"1": {
																				"name": "comment.block.dochead.c"
																				}
																		}
												},
												{
																		"match": "\\s*([<](http[s]?|mailto)\\S*[>])(\\s*)",
																		"captures": {
																		"1": {
																				"name": "comment.block.link.c"
																				}
																		}
												},
												{
																		"match": "\\s*(\\s[*]\\S*[*])(\\s*)",
																		"captures": {
																		"1": {
																				"name": "comment.block.bold.c"
																				}
																		}
												},
												{
																		"match": "\\s*(\\s[_]\\S*[_])(\\s*)",
																		"captures": {
																		"1": {
																				"name": "comment.block.underline.c"
																				}
																		}
												},
												{
																		"match": "\\s*(##[#]*)\\s*",
																		"captures": {
																		"1": {
																				"name": "comment.block.seperator.c"
																				}
																		}
                                                },
                                                {
                                                    "match": "\\s+([!][^\\* \\t\\n]*)\\s*",
                                                    "captures": {
                                                    "1": {
                                                            "name": "comment.block.token.c"
                                                            }
                                                }
                            }
                    ]
                },
                {
                    "match": "\\*/(?![/*])",
                    "name": "invalid.illegal.stray-comment-end.c"
                },
                {
                    "begin": "\\s*(//)",
                    "beginCaptures": {
                        "1": {
                            "name": "punctuation.definition.comment.line.double-slash.c++"
                        }
                    },
                    "end": "(?<=$\\n)(?<!\\\\$\\n)",
                    "name": "comment.line.double-slash.c++",
                    "patterns": [
                        {
                            "include": "#comment-innards"
                        }
                    ]
                }
            ]
        },
        "comment-innards": {
            "patterns": [
                {
                    "include": "#comment-banner-line"
                },
                {
                    "include": "#comment-task-tag-line"
                },
                {
                    "include": "#lex-continuation"
                },
                {
                    "include": "#lex-newline"
                }
            ]
        },
        "comment-banner-line": {
            "match": "(?:(?<=//)|(?<=/\\*)|^)[\\s/*]*(=+\\s*(.*?)\\s*=+(?:(?=[\\s/*+\\-]*\\*/)|$(\\n?)))",
            "captures": {
                "1": {
                    "name": "meta.toc-list.banner.c"
                },
                "3": {
                    "name": "punctuation.whitespace.newline.c"
                }
            }
        },
        "comment-task-tag-line": {
            "patterns": [
                {
                    "begin": "(?ix)\n\t\t\t\t\t    (?= (?-i: @[a-zA-Z_]++ | \\b [A-Z_]++) \\b) @? \\b (?:\n\t\t\t\t\t        (FIXME) | (XXX) | (WTF)\n\t\t\t\t\t    ) \\b\n\t\t\t\t\t",
                    "beginCaptures": {
                        "0": {
                            "name": "keyword.other.task-tag.prio-high.c"
                        },
                        "1": {
                            "name": "storage.type.class.fixme.c"
                        },
                        "2": {
                            "name": "storage.type.class.xxx.c"
                        },
                        "3": {
                            "name": "storage.type.class.wtf.c"
                        }
                    },
                    "end": "(?=[\\s/*]*\\*/)|(?<=$\\n)",
                    "name": "meta.toc-list.task-tag.prio-high.c",
                    "patterns": [
                        {
                            "include": "#comment-task-tag-line-innards"
                        }
                    ]
                },
                {
                    "begin": "(?ix)\n\t\t\t\t\t    (?= (?-i: @[a-zA-Z_]++ | \\b [A-Z_]++) \\b) @? \\b (?:\n\t\t\t\t\t        (TODO)\n\t\t\t\t\t    ) \\b\n\t\t\t\t\t",
                    "beginCaptures": {
                        "0": {
                            "name": "keyword.other.task-tag.prio-normal.c"
                        },
                        "1": {
                            "name": "storage.type.class.todo.c"
                        }
                    },
                    "end": "(?=[\\s/*]*\\*/)|(?<=$\\n)",
                    "name": "meta.toc-list.task-tag.prio-normal.c",
                    "patterns": [
                        {
                            "include": "#comment-task-tag-line-innards"
                        }
                    ]
                },
                {
                    "begin": "(?ix)\n\t\t\t\t\t    (?= (?-i: @[a-zA-Z_]++ | \\b [A-Z_]++) \\b) @? \\b (?:\n\t\t\t\t\t        (TBD) | (REVIEW)\n\t\t\t\t\t    ) \\b\n\t\t\t\t\t",
                    "beginCaptures": {
                        "0": {
                            "name": "keyword.other.task-tag.prio-low.c"
                        },
                        "1": {
                            "name": "storage.type.class.tbd.c"
                        },
                        "2": {
                            "name": "storage.type.class.review.c"
                        }
                    },
                    "end": "(?=[\\s/*]*\\*/)|(?<=$\\n)",
                    "name": "meta.toc-list.task-tag.prio-low.c",
                    "patterns": [
                        {
                            "include": "#comment-task-tag-line-innards"
                        }
                    ]
                },
                {
                    "begin": "(?ix)\n\t\t\t\t\t    (?= (?-i: @[a-zA-Z_]++ | \\b [A-Z_]++) \\b) @? \\b (?:\n\t\t\t\t\t        (NOTE) | (NB) | (CHANGED) | (IDEA) | (IMPORTANT) | (HACK) | (BUG)\n\t\t\t\t\t    ) \\b\n\t\t\t\t\t",
                    "beginCaptures": {
                        "0": {
                            "name": "keyword.other.task-tag.note.c"
                        },
                        "1": {
                            "name": "storage.type.class.note.c"
                        },
                        "2": {
                            "name": "storage.type.class.nb.c"
                        },
                        "3": {
                            "name": "storage.type.class.changed.c"
                        },
                        "4": {
                            "name": "storage.type.class.idea.c"
                        },
                        "5": {
                            "name": "storage.type.class.important.c"
                        },
                        "6": {
                            "name": "storage.type.class.hack.c"
                        },
                        "7": {
                            "name": "storage.type.class.bug.c"
                        }
                    },
                    "end": "(?=[\\s/*]*\\*/)|(?<=$\\n)",
                    "name": "meta.toc-list.task-tag.note.c",
                    "patterns": [
                        {
                            "include": "#comment-task-tag-line-innards"
                        }
                    ]
                }
            ]
        },
        "comment-task-tag-line-innards": {
            "patterns": [
                {
                    "include": "#comment-task-tag-line"
                },
                {
                    "include": "#lex-continuation"
                },
                {
                    "include": "#lex-newline"
                }
            ]
        },
        "lex": {
            "patterns": [
                {
                    "include": "#lex-in-preprocessor"
                },
                {
                    "include": "#preprocessor"
                }
            ]
        },
        "lex-in-preprocessor": {
            "patterns": [
                {
                    "include": "#lex-core"
                },
                {
                    "include": "#lex-keyword"
                },
                {
                    "include": "#lex-constant"
                }
            ]
        },
        "lex-core": {
            "patterns": [
                {
                    "include": "#comments"
                },
                {
                    "include": "#lex-access"
                },
                {
                    "include": "#lex-continuation"
                },
                {
                    "include": "#lex-newline"
                },
                {
                    "include": "#lex-number"
                },
                {
                    "include": "#lex-string"
                },
                {
                    "include": "#lex-termination"
                }
            ]
        },
        "lex-access": {
            "match": "(?:(?<=\\.)|(?<=->))\\b([a-zA-Z_]\\w*+)\\b(?!(?:\\s|/\\*.*?\\*/)*+\\()",
            "name": "variable.other.dot-access.c"
        },
        "lex-continuation": {
            "patterns": [
                {
                    "match": "(\\\\)$(\\n?)",
                    "name": "punctuation.separator.continuation.c",
                    "captures": {
                        "1": {
                            "name": "keyword.other.line-continuation.c"
                        },
                        "2": {
                            "name": "punctuation.whitespace.newline.c"
                        }
                    }
                },
                {
                    "match": "\\\\(\\s+?)(?=\\n)$",
                    "captures": {
                        "1": {
                            "name": "invalid.deprecated.space-after-continuation.c"
                        }
                    }
                }
            ]
        },
        "lex-newline": {
            "match": "$\\n",
            "name": "punctuation.whitespace.newline.c"
        },
	"lex-termination": {
            "match": ";",
            "name": "punctuation.terminator.statement.c"
        },
        "lex-keyword": {
            "patterns": [
                {
                    "match": "\\s*\\b(sizeof|(?:__|(?!\\w+__))typeof(?:__)?)\\b",
                    "captures": {
                        "1": {
                            "name": "keyword.operator.c"
                        }
                    }
                },
                {
                    "match": "\\s*\\b((?:__|(?!\\w+__))asm(?:__)?|break|case|continue|default|do|else|for|goto|if|_Pragma|return|switch|while|__extension__)\\b",
                    "captures": {
                        "1": {
                            "name": "keyword.control.c"
                        }
                    }
                },
                {
                    "match": "\\s*\\b(auto|bool|_Bool|char|_Complex|double|float|_Imaginary|int|long|short|signed|unsigned|void)\\b",
                    "captures": {
                        "1": {
                            "name": "storage.type.c"
                        }
                    }
                },
                {
                    "match": "\\s*\\b(extern|static|register|__attribute__|(?:__|(?!\\w+__))(?:const|restrict|volatile|inline)(?:__)?)\\b",
                    "captures": {
                        "1": {
                            "name": "storage.modifier.c"
                        }
                    }
                },
                {
                    "match": "\\s*\\b(class|struct|union|enum|typedef)\\b",
                    "captures": {
                        "1": {
                            "name": "storage.type.c"
                        }
                    }
                },
                {
                    "match": "(\\-|\\+|\\*|\\/|%|&|\\||\\^|<<|>>)?=",
                    "name": "keyword.operator.assignment.c"
                },
                {
                    "match": "(==|!=|<=|>=|<>|<|>)",
                    "name": "keyword.operator.comparison.c"
                },
                {
                    "match": "(\\-\\-|\\+\\+)",
                    "name": "keyword.operator.increment-decrement.c"
                },
                {
                    "match": "(\\?|:)",
                    "name": "keyword.operator.ternary.c"
                },
                {
                    "match": "(\\-|\\+|\\*|\\/|%)",
                    "name": "keyword.operator.arithmetic.c"
                },
                {
                    "match": "(!|&&|\\|\\|)",
                    "name": "keyword.operator.logical.c"
                },
                {
                    "match": "(~|&|\\||\\^|<<|>>)",
                    "name": "keyword.operator.bitwise.c"
                },
                {
                    "match": "(\\.|->)(?=(?:\\s|/\\*.*?\\*/)*+[A-Za-z_]\\w*+)",
                    "name": "keyword.operator.dereference.c"
                }
            ]
        },
        "lex-constant": {
            "patterns": [
		        {
                    "match": "\\s*\\b(true|TRUE|YES|NULL|VALID|SUCCESS|DONE|FINISH|EXIT_SUCCESS)\\b",
                    "captures": {
                        "1": {
                            "name": "constant.return.success.c"
                        }
                    }
                },
		        {
                    "match": "\\s*\\b(false|FALSE|NO|EXCEPTION|INVALID|FAILURE|EXIT_FAILURE)\\b",
                    "captures": {
                        "1": {
                            "name": "constant.return.failure.c"
                        }
                    }
                },
		        {
                    "match": "\\s*\\b(error|ERROR|UNDEF|PFAULT|EXIT_PFAULT|EXIT_ERROR)\\b",
                    "captures": {
                        "1": {
                            "name": "constant.return.error.c"
                        }
                    }
                }
            ]
        },
        "lex-number": {
            "patterns": [
                {
                    "match": "(?ix)  # hexadecimal float\n\t\t\t\t\t\t(?<!\\.) \\b\n\n\t\t\t\t\t\t(0x)\n\n\t\t\t\t\t\t# significand\n\t\t\t\t\t\t(?: (\\.) (?=p)  # invalid\n\t\t\t\t\t\t  |        [0-9a-f]*+ ([0-9a-z]*?) [0-9a-f]*+\n\t\t\t\t\t\t    (?: \\. [0-9a-f]*+ ([0-9a-z.]*?) [0-9a-f]*+ )? )\n\n\t\t\t\t\t\t# exponent (required)\n\t\t\t\t\t\t(?: (p) (?:        [+\\-]  [0-9]++ ([0-9a-z]*?)\n\t\t\t\t\t\t          | (?=[0-9a-z.]) [0-9]*+ ([0-9a-z.]*?) )\n\t\t\t\t\t\t  | (p) )\n\n\t\t\t\t\t\t# remaining valid chars and type\n\t\t\t\t\t\t[0-9]*+ ([fl]?)\n\n\t\t\t\t\t\t\\b (?!\\.)\n\t\t\t\t\t",
                    "name": "constant.numeric.float.hexadecimal.c",
                    "captures": {
                        "1": {
                            "name": "storage.type.number.prefix.hexadecimal.c"
                        },
                        "2": {
                            "name": "invalid.illegal.number.missing-fragment.significand.c"
                        },
                        "3": {
                            "name": "invalid.illegal.numeric-literal-character.float.whole-number.c"
                        },
                        "4": {
                            "name": "invalid.illegal.numeric-literal-character.float.fraction.c"
                        },
                        "5": {
                            "name": "keyword.other.exponent.hexadecimal.c"
                        },
                        "6": {
                            "name": "invalid.illegal.numeric-literal-character.float.exponent.c"
                        },
                        "7": {
                            "name": "invalid.illegal.numeric-literal-character.float.exponent.c"
                        },
                        "8": {
                            "name": "invalid.illegal.number.missing-fragment.exponent.c"
                        },
                        "9": {
                            "name": "storage.type.number.suffix.float.c"
                        }
                    }
                },
                {
                    "match": "(?ix)  # hexadecimal float without required exponent\n\t\t\t\t\t\t(?<!\\.) \\b\n\n\t\t\t\t\t\t(0x)\n\n\t\t\t\t\t\t# significand (at least a period)\n\t\t\t\t\t\t     [0-9a-f]*+ ([0-9a-z&&[^p]]*?) [0-9a-f]*+\n\t\t\t\t\t\t(\\.) [0-9a-f]*+ ([0-9a-z.&&[^p]]*?) [0-9a-f]*+\n\n\t\t\t\t\t\t# type\n\t\t\t\t\t\t(l?)\n\n\t\t\t\t\t\t(?:(?<=\\.)|\\b) (?!\\.)\n\t\t\t\t\t",
                    "name": "constant.numeric.float.hexadecimal.c",
                    "captures": {
                        "1": {
                            "name": "storage.type.number.prefix.hexadecimal.c"
                        },
                        "2": {
                            "name": "invalid.illegal.numeric-literal-character.float.whole-number.c"
                        },
                        "3": {
                            "name": "invalid.illegal.number.hexadecimal-float-requires-exponent.c"
                        },
                        "4": {
                            "name": "invalid.illegal.numeric-literal-character.float.fraction.c"
                        },
                        "5": {
                            "name": "storage.type.number.suffix.float.c"
                        }
                    }
                },
                {
                    "match": "(?ix)  # decimal float literal\n\t\t\t\t\t\t(?<!\\.) (?:(?=\\.)|\\b)\n\n\t\t\t\t\t\t(?!0x)\n\t\t\t\t\t\t# significand\n\t\t\t\t\t\t(?: (?: [0-9]++ ([0-9a-z&&[^e]]*?) [0-9]*+ )?\n\t\t\t\t\t\t    \\.  [0-9]++ ([0-9a-z.&&[^e]]*?) [0-9]*+\n\n\t\t\t\t\t\t  |     [0-9]++ ([0-9a-z&&[^e]]*?) [0-9]*+ (?: \\. | (?=e)) )\n\n\t\t\t\t\t\t# exponent (optional)\n\t\t\t\t\t\t(?: (e) (?: [+\\-]  [0-9]++ ([0-9a-z]*?)\n\t\t\t\t\t\t          |        [0-9]++ ([0-9a-z.]*?) )\n\t\t\t\t\t\t  | ( p     [+\\-]? [0-9]++\n\t\t\t\t\t\t    | [ep]                  [0-9a-z.]*?) )?\n\n\t\t\t\t\t\t# any invalid chars and type\n\t\t\t\t\t\t([0-9a-z]*?) [0-9]*+ ([fl]?)\n\n\t\t\t\t\t\t(?:(?<=\\.)|\\b) (?!\\.)\n\t\t\t\t\t",
                    "name": "constant.numeric.float.c",
                    "captures": {
                        "1": {
                            "name": "invalid.illegal.numeric-literal-character.float.whole-number.c"
                        },
                        "2": {
                            "name": "invalid.illegal.numeric-literal-character.float.fraction.c"
                        },
                        "3": {
                            "name": "invalid.illegal.numeric-literal-character.float.whole-number.c"
                        },
                        "4": {
                            "name": "keyword.other.exponent.decimal.c"
                        },
                        "5": {
                            "name": "invalid.illegal.numeric-literal-character.float.exponent.c"
                        },
                        "6": {
                            "name": "invalid.illegal.numeric-literal-character.float.exponent.c"
                        },
                        "7": {
                            "name": "invalid.illegal.numeric-literal-character.float.exponent.c"
                        },
                        "8": {
                            "name": "invalid.illegal.numeric-literal-character.float.exponent.c"
                        },
                        "9": {
                            "name": "storage.type.number.suffix.float.c"
                        }
                    }
                },
                {
                    "match": "(?ix)\n\t\t\t\t\t\t(?<!\\.) \\b\n\t\t\t\t\t\t(0x)? 0++\n\t\t\t\t\t\t(u?l{0,2}|lul?|llu)\n\t\t\t\t\t\t\\b (?!\\.)\n\t\t\t\t\t",
                    "name": "constant.numeric.integer.zero.c",
                    "captures": {
                        "1": {
                            "name": "storage.type.number.prefix.hexadecimal.c"
                        },
                        "2": {
                            "name": "storage.type.number.suffix.c"
                        }
                    }
                },
                {
                    "match": "(?ix)\n\t\t\t\t\t\t(?<!\\.) \\b\n\n\t\t\t\t\t\t(?: (0x) | (0b) )\n\t\t\t\t\t\t(u?l{0,2}|lul?|llu)\n\n\t\t\t\t\t\t\\b (?!\\.)\n\t\t\t\t\t",
                    "name": "invalid.illegal.invalid-number-literal.c"
                },
                {
                    "match": "(?ix)\n\t\t\t\t\t\t(?<!\\.) \\b\n\n\t\t\t\t\t\t(0x) [0-9a-f]++\n\n\t\t\t\t\t\t# any invalid chars\n\t\t\t\t\t\t([0-9a-z]*?)\n\n\t\t\t\t\t\t# the remainder (after invalid chars, if any) and a type\n\t\t\t\t\t\t[0-9a-f]* (u?l{0,2}|lul?|llu)\n\n\t\t\t\t\t\t\\b (?!\\.)\n\t\t\t\t\t",
                    "name": "constant.numeric.integer.hexadecimal.c",
                    "captures": {
                        "1": {
                            "name": "storage.type.number.prefix.hexadecimal.c"
                        },
                        "2": {
                            "name": "invalid.illegal.numeric-literal-character.integer.c"
                        },
                        "3": {
                            "name": "storage.type.number.suffix.c"
                        }
                    }
                },
                {
                    "match": "(?ix)\n\t\t\t\t\t\t(?<!\\.) \\b\n\n\t\t\t\t\t\t(0b) [01]++\n\n\t\t\t\t\t\t# any invalid chars\n\t\t\t\t\t\t([0-9a-z]*?)\n\n\t\t\t\t\t\t# the remainder (after invalid chars, if any) and a type\n\t\t\t\t\t\t[01]* (u?l{0,2}|lul?|llu)\n\n\t\t\t\t\t\t\\b (?!\\.)\n\t\t\t\t\t",
                    "name": "constant.numeric.integer.binary.c",
                    "captures": {
                        "1": {
                            "name": "storage.type.number.prefix.binary.c"
                        },
                        "2": {
                            "name": "invalid.illegal.numeric-literal-character.integer.c"
                        },
                        "3": {
                            "name": "storage.type.number.suffix.c"
                        }
                    }
                },
                {
                    "match": "(?ix)\n\t\t\t\t\t\t(?<!\\.) \\b\n\n\t\t\t\t\t\t(0) [0-7]++\n\n\t\t\t\t\t\t# any invalid chars\n\t\t\t\t\t\t([0-9a-z]*?)\n\n\t\t\t\t\t\t# the remainder (after invalid chars, if any) and a type\n\t\t\t\t\t\t[0-7]* (u?l{0,2}|lul?|llu)\n\n\t\t\t\t\t\t\\b (?!\\.)\n\t\t\t\t\t",
                    "name": "constant.numeric.integer.octal.c",
                    "captures": {
                        "1": {
                            "name": "storage.type.number.prefix.octal.c"
                        },
                        "2": {
                            "name": "invalid.illegal.numeric-literal-character.integer.c"
                        },
                        "3": {
                            "name": "storage.type.number.suffix.c"
                        }
                    }
                },
                {
                    "match": "(?ix)\n\t\t\t\t\t\t(?<!\\.) \\b\n\n\t\t\t\t\t\t[0-9]++\n\n\t\t\t\t\t\t# any invalid chars\n\t\t\t\t\t\t([0-9a-z]*?)\n\n\t\t\t\t\t\t# the remainder (after invalid chars, if any) and a type\n\t\t\t\t\t\t[0-9]* (u?l{0,2}|lul?|llu)\n\n\t\t\t\t\t\t\\b (?!\\.)\n\t\t\t\t\t",
                    "name": "constant.numeric.integer.decimal.c",
                    "captures": {
                        "1": {
                            "name": "invalid.illegal.numeric-literal-character.integer.c"
                        },
                        "2": {
                            "name": "storage.type.number.suffix.c"
                        }
                    }
                }
            ]
        },
        "lex-string": {
            "patterns": [
                {
                    "begin": "\"",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.definition.string.begin.c"
                        }
                    },
                    "end": "(\")|(?<=^|[^\\\\])\\s*(\\n)",
                    "endCaptures": {
                        "1": {
                            "name": "punctuation.definition.string.end.c"
                        },
                        "2": {
                            "name": "invalid.illegal.unexpected-end-of-line.c"
                        }
                    },
                    "name": "string.quoted.double.c",
                    "patterns": [
                        {
                            "include": "#lex-continuation"
                        },
                        {
                            "include": "#string_escaped_char"
                        },
                        {
                            "include": "#string_placeholder"
                        }
                    ]
                },
                {
                    "begin": "'",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.definition.string.begin.c"
                        }
                    },
                    "end": "(')|(?<=^|[^\\\\])\\s*(\\n)",
                    "endCaptures": {
                        "1": {
                            "name": "punctuation.definition.string.end.c"
                        },
                        "2": {
                            "name": "invalid.illegal.unexpected-end-of-line.c"
                        }
                    },
                    "name": "string.quoted.single.c",
                    "patterns": [
                        {
                            "include": "#lex-continuation"
                        },
                        {
                            "include": "#string_escaped_char"
                        }
                    ]
                }
            ]
        },
        "string_escaped_char": {
            "patterns": [
                {
                    "match": "\\\\(\\\\|[abefnprtv'\"?]|[0-3]\\d{,2}|[4-7]\\d?|x[a-fA-F0-9]{,2}|u[a-fA-F0-9]{,4}|U[a-fA-F0-9]{,8})",
                    "name": "constant.character.escape.c"
                },
                {
                    "match": "\\\\.",
                    "name": "invalid.illegal.unknown-escape.c"
                }
            ]
        },
        "string_placeholder": {
            "patterns": [
                {
                    "match": "(?x)%\n\t\t\t\t\t\t(\\d+\\$)?                             # field (argument #)\n\t\t\t\t\t\t[#0\\- +']*                           # flags\n\t\t\t\t\t\t[,;:_]?                              # separator character (AltiVec)\n\t\t\t\t\t\t((-?\\d+)|\\*(-?\\d+\\$)?)?              # minimum field width\n\t\t\t\t\t\t(\\.((-?\\d+)|\\*(-?\\d+\\$)?)?)?         # precision\n\t\t\t\t\t\t(hh|h|ll|l|j|t|z|q|L|vh|vl|v|hv|hl)? # length modifier\n\t\t\t\t\t\t[diouxXDOUeEfFgGaACcSspn%]           # conversion type\n\t\t\t\t\t",
                    "name": "constant.other.placeholder.c"
                },
                {
                    "match": "%",
                    "name": "invalid.illegal.placeholder.c"
                }
            ]
        }
    },
    "uuid": "24242A3A-CC4A-414D-B1FA-18D2BABB6754"
}
